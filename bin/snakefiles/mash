
#### Mash rules
rule mash:
    input:
        expand('data/{sample}/{run}/mash/{sample}.fna.msh',
               sample=SAMPLES_PE, run=RUN),
        expand('data/{sample}/{run}/mash/{sample}.refseq.txt',
               sample=SAMPLES_PE, run=RUN),
        expand("data/combined_analysis/{run}/mash/mash.dist.dm", run=RUN),
        expand("data/combined_analysis/{run}/mash/mash.dist.p", run=RUN)



rule mash_sketch:
    """
    Sketches a trimmed and host-filtered fastq file. 
    
    There is almost no documentation for this tool, so it's problematic.

    Relevant parameters might be:
    -b : use bloom filtering on kmers to reduce impact of low-freq erros.
    -m N: use explicit depth filtering on kmers (bigger memory impact than bloom)
    """
    input:
        forward  = "data/{sample}/{run}/host_filtered/{sample}_R1.trimmed.host_filtered.fq.gz",
        reverse  = "data/{sample}/{run}/host_filtered/{sample}_R2.trimmed.host_filtered.fq.gz",
        unpaired_1 = "data/{sample}/{run}/host_filtered/{sample}_U1.trimmed.host_filtered.fq.gz",
        unpaired_2 = "data/{sample}/{run}/host_filtered/{sample}_U2.trimmed.host_filtered.fq.gz"
    output:
        'data/{sample}/{run}/mash/{sample}.fna.msh'
    params:
        mash = config['SOFTWARE']['mash'],
        seqtk = config['SOFTWARE']['seqtk'],
        mash_params = config['PARAMS']['MASH']['OTHER'],
        output_base = 'data/{sample}/{run}/mash/{sample}.fna'
    threads:
        1
    log:
        "logs/{run}/analysis/mash_sketch_{sample}.log"
    benchmark:
        "benchmarks/{run}/analysis/mash_sketch_{sample}.json"
    run:
        with tempfile.TemporaryDirectory(dir=TMP_DIR_ROOT) as temp_dir:
            shell("""
                  {params.seqtk} seq -a {input.forward} > {temp_dir}/R1.fna
                  {params.seqtk} seq -a {input.reverse} > {temp_dir}/R2.fna
                  {params.seqtk} seq -a {input.unpaired_1} > {temp_dir}/U1.fna
                  {params.seqtk} seq -a {input.unpaired_2} > {temp_dir}/U2.fna

                  cat {temp_dir}/R1.fna {temp_dir}/R2.fna {temp_dir}/U1.fna {temp_dir}/U2.fna > {temp_dir}/{wildcards.sample}

                  {params.mash} sketch {params.mash_params} -o {params.output_base} {temp_dir}/{wildcards.sample}
                  """)


rule mash_refseq:
    """
    Compares a mash sketch against refseq sketch. 

    Requires that the sketches have same -k values -- for RefSeqDefault, 
    -k should equal 21. 
    """
    input:
        'data/{sample}/{run}/mash/{sample}.fna.msh'
    output:
        'data/{sample}/{run}/mash/{sample}.refseq.txt'
    params:
        mash = config['SOFTWARE']['mash'],
        db = config['PARAMS']['MASH']['REFSEQ_DB']
    threads:
        1
    log:
        "logs/{run}/analysis/mash_refseq_{sample}.log"
    benchmark:
        "benchmarks/{run}/analysis/mash_refseq_{sample}.json"
    run:
        shell("""
              {params.mash} dist {params.db} {input} | sort -gk3 > {output}
              """)

rule mash_dm:
    """
    Makes mash distance output file
    """
    input:
        expand( # trimmomatic output for PE data
            "data/{sample}/{run}/mash/{sample}.fna.msh",
            sample = SAMPLES_PE,
            run = RUN)
    output:
        "data/combined_analysis/{run}/mash/mash.dist.txt"
    params:
        mash = config['SOFTWARE']['mash']
    threads:
        1
    log:
        "logs/{run}/analysis/mash_dm.log"
    benchmark:
        "benchmarks/{run}/analysis/mash_dm.json"
    run:
        for i in range(len(input)):
            for j in range(i,len(input)):
                thing1 = input[i]
                thing2 = input[j]
                shell("""
                      {params.mash} dist {thing1} {thing2} >> {output}
                      """)

rule mash_dm_write:
    """
    Writes square distance matrices from p values and distances that Mash makes
    """
    input:
        "data/combined_analysis/{run}/mash/mash.dist.txt"
    output:
        dist_matrix = "data/combined_analysis/{run}/mash/mash.dist.dm",
        p_matrix = "data/combined_analysis/{run}/mash/mash.dist.p"
    threads:
        1
    log:
        "logs/{run}/analysis/mash_dm_write.log"
    benchmark:
        "benchmarks/{run}/analysis/mash_dm_write.json"
    run:
        from skbio.stats.distance import DissimilarityMatrix
        import pandas as pd
        import numpy as np

        mash_vec = pd.read_csv(input[0], sep = '\t', header=None)

        # get sorted list of samples
        samples = sorted(set(mash_vec[0]) | set(mash_vec[1]))

        dm = np.zeros([len(samples),len(samples)])
        pm = np.zeros([len(samples),len(samples)])

        # fill matrices with values
        for s1, s2, d, p in zip(mash_vec[0],mash_vec[1],mash_vec[2],mash_vec[3]):
            i1 = samples.index(s1)
            i2 = samples.index(s2)
            print('s1: %s, s2: %s, i1: %s, i2: %s, d: %s, p: %s' % (s1, s2, i1, i2, d, p))
            dm[i1,i2] = d
            dm[i2,i1] = d
            pm[i1,i2] = p
            pm[i2,i1] = p

        ids = [os.path.basename(x) for x in samples]
        sk_dm = DissimilarityMatrix(dm, ids=ids)
        sk_pm = DissimilarityMatrix(pm, ids=ids)

        sk_dm.write(output['dist_matrix'])
        sk_pm.write(output['p_matrix'])

